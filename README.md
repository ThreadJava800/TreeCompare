# Сравнение производительности различных деревьев поиска.

## Содержание
1. [Наивное двоичное дерево поиска](#bin)
2. [AVL-дерево](#avl)
3. [Декартово дерево](#treap)\
4. [Splay дерево](#splay)

## Наивное двоичное дерево поиска <a name="bin"></a>
Сначала было произведено 100000 добавление случайных данных в дерево.\
После этого, из дерева было удалено 50000 элементов.\
Все измерения совершались раз, а затем бралось медианное время.

| Операция | Время (мс) |
|---|---|
| Добавление случайных данных | 31.0 |
| Удаление случайных данных | 13.4 |

Однако, одним из самых больших недостатков этого дерево, является высокая вероятность вырождения в бамбук. Таким образом, максимальное время работы возрастает. Более конкретно это видно в таблице:
Далее были проведены те же тесты, но с отсортированными данными (элементы добавлялись последовательно).
| Операция | Время (мс) |
|---|---|
| Добавление случайных данных | 31.0 |
| Удаление случайных данных | 13.4 |
| Добавление отсортированных данных | 25135.8 |
| Удаление отсортированных данных | 3427.4 |

## AVL-дерево <a name="avl"></a>
Далее аналогичные тесты были запущены для AVL дерева.
### Добавление (случайные данные)
![addrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/addAvl.png)
### Удаление (случайные данные)
![delrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/delAvl.png)

С отсортированными данными результат был тем же, что и в наивном дереве поиска. Различные реализации так же не имели никаких отличий.

## Декартово дерево <a name="treap"></a>
Ниже приведены результаты аналогичных тестов для декартова дерева (случайные данные).\
![addrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/treapAdd.png)\
![delrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/treapDel.png)

Как можем заметить, добавление работает примерно за одинаковое время (в пределах по грешности). А вот удаление из дерева в декартаче работает дольше, чем в остальных деревьях.

## Splay дерево <a name="splay"></a>
Протестируем производительность Splay дерева. Как можем видеть, операции вставки, а тем более удаления работают дольше, чем в других деревьях. С другой стороны, мы получаем дерево, с гарантированно логарифмической высотой, засчёт чего поиск осуществляется эффективней, чем в других деревьях.

![addrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/splayAdd.png)\
![delrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/splayDel.png)
