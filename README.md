# Сравнение производительности различных деревьев поиска.

## Содержание
1. [Наивное двоичное дерево поиска](#bin)
2. [AVL-дерево](#avl)

## Наивное двоичное дерево поиска <a name="bin"></a>
Сначала было произведено 100000 добавление случайных данных в дерево.\
После этого, из дерева было удалено 50000 элементов.\
Все измерения совершались раз, а затем бралось медианное время.

| Операция | Время (мс) |
|---|---|
| Добавление случайных данных | 31.0 |
| Удаление случайных данных | 13.4 |

Однако, одним из самых больших недостатков этого дерево, является высокая вероятность вырождения в бамбук. Таким образом, максимальное время работы возрастает. Более конкретно это видно в таблице:
Далее были проведены те же тесты, но с отсортированными данными (элементы добавлялись последовательно).
| Операция | Время (мс) |
|---|---|
| Добавление случайных данных | 31.0 |
| Удаление случайных данных | 13.4 |
| Добавление отсортированных данных | 25135.8 |
| Удаление отсортированных данных | 3427.4 |

## AVL-дерево <a name="avl"></a>
Далее аналогичные тесты были запущены для AVL дерева.
### Добавление (случайные данные)
![addrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/addAvl.png)
### Удаление (случайные данные)
![delrand](https://github.com/ThreadJava800/TreeCompare/blob/main/graphs/delAvl.png)

С отсортированными данными результат был тем же, что и в наивном дереве поиска. Различные реализации так же не имели никаких отличий.